syntax = "proto3";

package dev.preco.nxzr;

import "google/protobuf/timestamp.proto";

// Keeps track of `tracing` outputs wired through gRPC requests.
service Tracing {
  rpc LogStream(LogStreamRequest) returns (stream LogStreamResponse) {}
}

message LogStreamRequest {}
message LogStreamResponse {
  // The client will need to manually parse the message for log levels, timestamp, etc...
  string tracing_json = 1;
}

// Manages connection between the Switch and the server daemon.
service Nxzr {
  // Can be used for cross-checking if the selected connection from the client
  // side is still valid on the server.
  rpc GetConnectionStatus(GetConnectionStatusRequest) returns (GetConnectionStatusResponse) {}
  // FIXME: there's no disconnect method, just drop the stream to disconnect.
  // follow error design guide: https://jbrandhorst.com/post/grpc-errors/
  rpc Connect(ConnectRequest) returns (stream ConnectResponse) {}
  rpc Reconnect(ReconnectRequest) returns (stream ReconnectResponse) {}
  // rpc Disconnect()

  // For protocol inquiry.
  rpc ProtocolEventStream(ProtocolEventStreamRequest) returns (stream ProtocolEventStreamResponse) {}
  rpc GetProtocolState(GetProtocolStateRequest) returns (GetProtocolStateResponse) {}

  // For high-frequency controller state updates.
  rpc ButtonStream(stream ButtonStreamRequest) returns (stream ButtonStreamResponse) {}
  rpc StickStream(stream StickStreamRequest) returns (stream StickStreamResponse) {}
  rpc ImuStream(stream ImuStreamRequest) returns (stream ImuStreamResponse) {}
}

message GetConnectionStatusRequest {}
message GetConnectionStatusResponse {
  message Device {
    uint32 dev_id = 1;
    string address = 2;
  }
  repeated Device paired_devices = 1;
  string adapter_address = 2;
}

message ConnectRequest {
  optional uint32 dev_id = 1;
}
message ConnectResponse {
  ConnectionInfo conn_info = 1;
}

message ReconnectRequest {
  optional uint32 dev_id = 1;
  string reconnect_address = 2;
}
message ReconnectResponse {
  ConnectionInfo conn_info = 1;
}

message ProtocolEventStreamRequest {}
message ProtocolEventStreamResponse {
  message LogObj {
    enum LogType {
      UNSPECIFIED = 0;
      CLOSING = 1;
      CLOSED = 2;
      PAIRING_SUCCESS = 3;
      SUBCOMMAND_RECEIVED = 4;
    }
    LogType type = 1;
    string message = 2;
  }
  oneof event {
    LogObj log = 1;
    Error error = 2;
    Error warning = 3;
  };
}

message GetProtocolStateRequest {}
message GetProtocolStateResponse {
  bool is_pairing = 1;
  double send_interval = 2;
  optional uint32 report_mode = 3;
  google.protobuf.Timestamp connected_at = 4;
  string controller_state_dump = 5;
}

message ButtonStreamRequest {
  message Button {
    enum KeyAction {
      UNSPECIFIED = 0;
      PRESS = 1;
      UP = 2;
      DOWN = 3;
    }
    string key_type = 2;
    KeyAction key_action = 3;
  }
  string action_id = 1;
  Button button = 2;
}
message ButtonStreamResponse {
  string action_id = 1;
  bool success = 2;
}

message StickStreamRequest {
  string action_id = 1;
  Position position = 2;
}
message StickStreamResponse {
  string action_id = 1;
  bool success = 2;
}

message ImuStreamRequest {
  string action_id = 1;
  Position position = 2;
}
message ImuStreamResponse {
  string action_id = 1;
  bool success = 2;
}

message Position {
  uint32 x = 1;
  uint32 y = 2;
}

message ConnectionInfo {
  uint32 dev_id = 1;
  string adapter_address = 2;
  string target_address = 3;
}

message Error {
  string message = 1;
  google.protobuf.Timestamp timestamp = 2;
}
